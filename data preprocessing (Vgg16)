import os
import cv2
import numpy as np
from tqdm import tqdm
import shutil
from sklearn.model_selection import train_test_split

# --- Configuration ---
RAW_DATA_DIR = 'data/raw_dataset/'
VGG_OUTPUT_DIR = 'data/vgg16_classification/'
VGG_IMG_SIZE = 224 
SPLIT_RATIO = [0.70, 0.15, 0.15] # Train:Val:Test

# Expected Class Folders in RAW_DATA_DIR (Update this based on your dataset)
CLASSES = ['NO_TUMOR', 'GLIOMA', 'MENINGIOMA', 'PITUITARY']
SPLIT_NAMES = ['train', 'val', 'test']

# --- Utility Function: Image Cropping ---

def crop_brain_region(img):
    """
    Identifies the brain region by contour detection and crops the image.
    This effectively removes non-brain black background padding.
    """
    if img is None:
        return None

    # Convert to grayscale and apply Gaussian blur
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (5, 5), 0)

    # Thresholding to separate the brain from the background
    _, thresh = cv2.threshold(gray, 45, 255, cv2.THRESH_BINARY)
    thresh = cv2.erode(thresh, None, iterations=2)
    thresh = cv2.dilate(thresh, None, iterations=2)
    
    # Find contours
    contours, _ = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if not contours:
        # Fallback: if no contour found, return original image
        return img 

    # Find the largest contour (assumed to be the brain)
    c = max(contours, key=cv2.contourArea)

    # Get bounding box (x, y, w, h)
    x, y, w, h = cv2.boundingRect(c)
    
    # Crop the image with a small buffer for safety
    buffer = 10
    cropped_img = img[
        max(0, y - buffer):y + h + buffer, 
        max(0, x - buffer):x + w + buffer
    ]

    return cropped_img

# --- Main Preprocessing Function ---

def prepare_vgg_data():
    
    # 0. Setup and Data Collection
    
    # Ensure raw data exists and output directories are clean/created
    if not os.path.exists(RAW_DATA_DIR):
        print(f"Error: Raw data directory '{RAW_DATA_DIR}' not found.")
        return

    # Clear previous output and create the final structure
    if os.path.exists(VGG_OUTPUT_DIR):
        shutil.rmtree(VGG_OUTPUT_DIR)
    
    for split in SPLIT_NAMES:
        for class_name in CLASSES:
            os.makedirs(os.path.join(VGG_OUTPUT_DIR, split, class_name), exist_ok=True)
            
    # Collect all file paths and their classes
    all_files = []
    for class_name in CLASSES:
        class_path = os.path.join(RAW_DATA_DIR, class_name)
        if os.path.isdir(class_path):
            for file_name in os.listdir(class_path):
                if file_name.lower().endswith(('.jpg', '.png', '.jpeg')):
                    all_files.append((os.path.join(class_path, file_name), class_name))
    
    # 1. Stratified Train/Val/Test Split
    
    file_paths = [f[0] for f in all_files]
    class_labels = [f[1] for f in all_files]
    
    # Split 1: Train vs (Val + Test)
    train_paths, temp_paths, train_labels, temp_labels = train_test_split(
        file_paths, class_labels, train_size=SPLIT_RATIO[0], stratify=class_labels, random_state=42
    )
    
    # Split 2: Val vs Test
    val_test_ratio = SPLIT_RATIO[2] / (SPLIT_RATIO[1] + SPLIT_RATIO[2])
    val_paths, test_paths, val_labels, test_labels = train_test_split(
        temp_paths, temp_labels, test_size=val_test_ratio, stratify=temp_labels, random_state=42
    )

    splits = {
        'train': list(zip(train_paths, train_labels)), 
        'val': list(zip(val_paths, val_labels)), 
        'test': list(zip(test_paths, test_labels))
    }

    print(f"Total Images: {len(all_files)}")
    print(f"Train: {len(train_paths)}, Val: {len(val_paths)}, Test: {len(test_paths)}")

    # 2. Process and Save Files
    
    for split_name, file_list in splits.items():
        print(f"\nProcessing {split_name} set...")
        for file_path, class_name in tqdm(file_list):
            
            img = cv2.imread(file_path)
            
            # Step 1.2: Crop the brain region
            cleaned_img = crop_brain_region(img)
            
            if cleaned_img is None:
                print(f"Warning: Failed to process image {file_path}. Skipping.")
                continue

            # Step 1.3: Resize image to VGG-specific size (224x224)
            vgg_img = cv2.resize(cleaned_img, (VGG_IMG_SIZE, VGG_IMG_SIZE))
            
            # Step 1.4: Save the image into the final directory
            final_dir = os.path.join(VGG_OUTPUT_DIR, split_name, class_name)
            output_path = os.path.join(final_dir, os.path.basename(file_path))
            
            cv2.imwrite(output_path, vgg_img)

    print("\nâœ… VGG16 Preprocessing complete!")
    print(f"Output saved to: {VGG_OUTPUT_DIR}")

if __name__ == "__main__":
    prepare_vgg_data()
